# -*- coding: utf-8 -*-
"""
analyze_results.py

Analyze DeepPrint batch results stored as JSONL (one JSON object per line),
generated by run_my_fvc3.py --results-jsonl ...

Features:
- Load JSONL results
- Extract key metrics: EER, FNMR@target_fmr_main, thresholds, elapsed time
- Also extract FNMR/thr for common targets (0.05, 1e-3, 1e-4, 2e-5) if present
- Rank and print Top-K configs
- Save a flattened CSV for easy inspection
- Optional: plot simple figures (matplotlib)

Usage examples:

1) Print top 20 by FNMR@2e-05, save CSV:
   python analyze_results.py \
     --results ./examples/out/gmfs_white_results.jsonl \
     --topk 20 \
     --sort fnmr@2e-05 \
     --out-csv ./examples/out/gmfs_white_summary.csv

2) Sort by EER:
   python analyze_results.py --results ./examples/out/gmfs_white_results.jsonl --sort eer

3) Also draw plots:
   python analyze_results.py --results ./examples/out/gmfs_white_results.jsonl --plot
"""

import argparse
import json
import os
from typing import Any, Dict, List, Optional, Tuple

import math

def read_jsonl(path: str) -> List[Dict[str, Any]]:
    items: List[Dict[str, Any]] = []
    with open(path, "r", encoding="utf-8") as f:
        for ln, line in enumerate(f, 1):
            line = line.strip()
            if not line:
                continue
            try:
                items.append(json.loads(line))
            except json.JSONDecodeError as e:
                raise ValueError(f"Invalid JSON at line {ln} in {path}: {e}") from e
    return items

def safe_get(d: Dict[str, Any], key: str, default=None):
    return d.get(key, default) if isinstance(d, dict) else default

def parse_float(x) -> Optional[float]:
    try:
        if x is None:
            return None
        return float(x)
    except Exception:
        return None

def flatten_one(obj: Dict[str, Any], desired_targets: List[str]) -> Dict[str, Any]:
    """
    Flatten one result record into a single-row dict.
    Keep:
      - ts, model, data, device, elapsed_sec
      - config.* (common knobs)
      - metrics (eer, fnmr_main, thresholds)
      - targets (fnmr/thr for chosen target list)
    """
    row: Dict[str, Any] = {}

    row["ts"] = safe_get(obj, "ts", "")
    row["model"] = safe_get(obj, "model", "")
    row["data"] = safe_get(obj, "data", "")
    row["device"] = safe_get(obj, "device", "")
    row["elapsed_sec"] = parse_float(safe_get(obj, "elapsed_sec", None))

    cfg = safe_get(obj, "config", {}) or {}
    metrics = safe_get(obj, "metrics", {}) or {}
    targets = safe_get(obj, "targets", {}) or {}

    # --- config fields (keep some common ones, dump rest as json string) ---
    # Known/important knobs
    for k in [
        "name",
        "roi_mode",
        "mask_apply_mode",
        "crop_sizes",
        "angles",
        "clahe_clip",
        "clahe_grid",
        "blur_ksize",
        "rot_border",
        "fill",
        "alpha",
        "tex_pair_topk",
        "tex_spike_clip_enable",
        "tex_delta",
        "minu_gap_lam",
    ]:
        if k in cfg:
            row[f"cfg.{k}"] = cfg[k]

    # dump remaining config (so you don't lose anything)
    # (exclude those already saved)
    known = set([
        "name","roi_mode","mask_apply_mode","crop_sizes","angles","clahe_clip","clahe_grid",
        "blur_ksize","rot_border","fill","alpha","tex_pair_topk","tex_spike_clip_enable",
        "tex_delta","minu_gap_lam"
    ])
    extra_cfg = {k:v for k,v in cfg.items() if k not in known}
    row["cfg.extra_json"] = json.dumps(extra_cfg, ensure_ascii=False)

    # --- metrics ---
    row["eer"] = parse_float(metrics.get("eer"))
    row["eer_thr"] = parse_float(metrics.get("eer_thr"))
    row["fnmr_main"] = parse_float(metrics.get("fnmr_main"))
    row["thr_main"] = parse_float(metrics.get("thr_main"))
    row["n_gen"] = metrics.get("n_gen")
    row["n_imp"] = metrics.get("n_imp")

    # --- targets (string keys like "2e-05") ---
    for t in desired_targets:
        t_obj = targets.get(t)
        if isinstance(t_obj, dict):
            row[f"fnmr@{t}"] = parse_float(t_obj.get("fnmr"))
            row[f"thr@{t}"] = parse_float(t_obj.get("thr"))
        else:
            row[f"fnmr@{t}"] = None
            row[f"thr@{t}"] = None

    return row

def to_csv(rows: List[Dict[str, Any]], path: str):
    import csv
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)

    # union keys (stable order: common first, then the rest)
    common_first = [
        "ts","cfg.name","eer","fnmr_main","fnmr@2e-05","fnmr@0.0001","fnmr@0.001","fnmr@0.05",
        "eer_thr","thr_main","thr@2e-05","elapsed_sec","device","model","data",
        "cfg.roi_mode","cfg.mask_apply_mode",
        "cfg.crop_sizes","cfg.angles","cfg.alpha","cfg.tex_delta","cfg.minu_gap_lam",
        "cfg.tex_spike_clip_enable","cfg.tex_pair_topk",
        "cfg.clahe_clip","cfg.clahe_grid","cfg.blur_ksize","cfg.rot_border","cfg.fill",
        "cfg.extra_json","n_gen","n_imp",
    ]

    keyset = set()
    all_keys = []
    # add common keys if present in any row
    for k in common_first:
        if any(k in r for r in rows):
            all_keys.append(k)
            keyset.add(k)
    # add remaining keys
    for r in rows:
        for k in r.keys():
            if k not in keyset:
                all_keys.append(k)
                keyset.add(k)

    with open(path, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=all_keys)
        w.writeheader()
        for r in rows:
            w.writerow(r)

def _sort_key_factory(sort_key: str):
    """
    sort_key examples:
      - "fnmr@2e-05"
      - "fnmr_main"
      - "eer"
      - "elapsed_sec"
    """
    def keyfn(r: Dict[str, Any]):
        v = r.get(sort_key)
        # None should go to the end
        if v is None:
            return (1, float("inf"))
        try:
            fv = float(v)
        except Exception:
            return (1, float("inf"))
        return (0, fv)
    return keyfn

def print_top(rows: List[Dict[str, Any]], sort_key: str, topk: int, desired_targets: List[str]):
    rows_sorted = sorted(rows, key=_sort_key_factory(sort_key))
    print("\n==================== TOP RESULTS ====================")
    print(f"Sort by: {sort_key}  (lower is better)")
    print(f"Total runs: {len(rows)} | Show top {min(topk, len(rows))}\n")

    header = [
        "rank",
        "cfg.name",
        "eer(%)",
        "fnmr_main(%)",
        "fnmr@2e-05(%)",
        "fnmr@1e-4(%)",
        "elapsed(s)",
        "roi/mask",
        "alpha/delta/lam",
        "angles",
        "crop_sizes",
    ]
    print(" | ".join(header))
    print("-" * 140)

    for i, r in enumerate(rows_sorted[:topk], 1):
        name = r.get("cfg.name", "")
        eer = r.get("eer")
        fnmr_main = r.get("fnmr_main")
        fnmr_2e5 = r.get("fnmr@2e-05")
        fnmr_1e4 = r.get("fnmr@0.0001")
        el = r.get("elapsed_sec")

        roi = r.get("cfg.roi_mode", "")
        mask = r.get("cfg.mask_apply_mode", "")
        alpha = r.get("cfg.alpha", "")
        delta = r.get("cfg.tex_delta", "")
        lam = r.get("cfg.minu_gap_lam", "")

        angles = r.get("cfg.angles", "")
        crops = r.get("cfg.crop_sizes", "")

        def pct(x):
            return "" if x is None else f"{float(x)*100:6.2f}"

        el_s = "" if el is None else f"{float(el):6.1f}"

        print(
            f"{i:>4d} | "
            f"{str(name)[:28]:<28} | "
            f"{pct(eer):>6} | "
            f"{pct(fnmr_main):>10} | "
            f"{pct(fnmr_2e5):>11} | "
            f"{pct(fnmr_1e4):>10} | "
            f"{el_s:>8} | "
            f"{roi}/{mask} | "
            f"{alpha}/{delta}/{lam} | "
            f"{str(angles)[:30]:<30} | "
            f"{str(crops)[:22]:<22}"
        )

    print("=====================================================\n")

def plot_basic(rows: List[Dict[str, Any]], desired_targets: List[str], out_dir: str):
    """
    Make 2 simple plots:
      1) scatter: EER vs FNMR@2e-05
      2) line: best FNMR@2e-05 over rank
    """
    import matplotlib.pyplot as plt

    os.makedirs(out_dir, exist_ok=True)

    # collect values
    x_eer = []
    y_fn = []
    labels = []
    for r in rows:
        eer = r.get("eer")
        fn = r.get("fnmr@2e-05") if "2e-05" in desired_targets else r.get("fnmr_main")
        if eer is None or fn is None:
            continue
        x_eer.append(float(eer) * 100.0)
        y_fn.append(float(fn) * 100.0)
        labels.append(r.get("cfg.name", ""))

    if x_eer and y_fn:
        plt.figure()
        plt.xlabel("EER (%)")
        plt.ylabel("FNMR @ 2e-05 (%)")
        plt.scatter(x_eer, y_fn)
        plt.tight_layout()
        p1 = os.path.join(out_dir, "eer_vs_fnmr_2e-05.png")
        plt.savefig(p1, dpi=150)
        plt.close()
        print(f"[Plot] saved: {p1}")

    # rank curve
    ranked = sorted([r for r in rows if r.get("fnmr@2e-05") is not None],
                    key=_sort_key_factory("fnmr@2e-05"))
    vals = [float(r["fnmr@2e-05"]) * 100.0 for r in ranked]
    if vals:
        plt.figure()
        plt.xlabel("Rank (sorted by FNMR@2e-05)")
        plt.ylabel("FNMR @ 2e-05 (%)")
        plt.plot(list(range(1, len(vals) + 1)), vals)
        plt.tight_layout()
        p2 = os.path.join(out_dir, "fnmr_2e-05_rank_curve.png")
        plt.savefig(p2, dpi=150)
        plt.close()
        print(f"[Plot] saved: {p2}")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--results", required=True, help="Path to results.jsonl")
    ap.add_argument("--topk", type=int, default=20, help="Show top K results")
    ap.add_argument("--sort", default="fnmr@2e-05",
                    help="Sort key: e.g. fnmr@2e-05 | fnmr_main | eer | elapsed_sec")
    ap.add_argument("--out-csv", default=None, help="Save a flattened CSV summary")
    ap.add_argument("--plot", action="store_true", help="Save a couple simple plots")
    ap.add_argument("--plot-dir", default="./examples/out/plots", help="Where to save plots")

    # which target keys to extract from JSONL
    ap.add_argument("--targets", default="0.05,0.001,0.0001,2e-05",
                    help="Comma-separated target keys to extract from obj['targets'] (as strings).")

    args = ap.parse_args()

    desired_targets = [t.strip() for t in args.targets.split(",") if t.strip()]

    objs = read_jsonl(args.results)
    if not objs:
        raise ValueError(f"No records in {args.results}")

    rows = [flatten_one(o, desired_targets=desired_targets) for o in objs]

    # If the sort key is missing everywhere, warn & fallback
    if not any(args.sort in r and r[args.sort] is not None for r in rows):
        print(f"[Warn] sort key '{args.sort}' not found (or all None). Fallback to 'fnmr_main'.")
        args.sort = "fnmr_main"

    print_top(rows, sort_key=args.sort, topk=args.topk, desired_targets=desired_targets)

    if args.out_csv:
        to_csv(rows, args.out_csv)
        print(f"[Saved] CSV summary -> {args.out_csv}")

    if args.plot:
        plot_basic(rows, desired_targets=desired_targets, out_dir=args.plot_dir)

if __name__ == "__main__":
    main()
